{"componentChunkName":"component---node-modules-gatsby-theme-chronoblog-src-templates-post-js","path":"/java-memory-model/","result":{"data":{"mdx":{"id":"d075a19e-4c79-524a-ab3d-e0288554b667","excerpt":"Java Virtual Machine Technology The JDK provides one or more implementations of the Java™ virtual machine (VM):   On platforms typically…","frontmatter":{"title":"Everything about JVM, Java Memory Model and Garbage Collection","date":"2020-07-12T00:00:00.000Z","description":null,"tags":["post","java"],"cover":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wgARCAAKABQDAREAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAABQf/xAAXAQEBAQEAAAAAAAAAAAAAAAAFBAYH/9oADAMBAAIQAxAAAAEljPg4/o0lrkMQDZL0Ydo3/8QAHBAAAgICAwAAAAAAAAAAAAAAAQIDBAAFERMh/9oACAEBAAEFAp9ZpIA1Ss+X0SO0jHntcxk+/wD/xAAdEQACAgIDAQAAAAAAAAAAAAABAgADERIEBSEx/9oACAEDAQE/AV2Y5nW1q9eHWclK1sIEUexGOn2MTmf/xAAcEQADAAEFAAAAAAAAAAAAAAAAAQIRAwQQEiH/2gAIAQIBAT8BrCN3Tm8yzRdOE2W/BpduP//EAB8QAAIBBAIDAAAAAAAAAAAAAAECAAMREjIhMRBBkf/aAAgBAQAGPwIChVTPn32JjZApG1tZUVCGUHsQczdvvj//xAAbEAADAQADAQAAAAAAAAAAAAABETEAQVFhwf/aAAgBAQABPyF5uVR8uvcyOVwxNHAkcCQEC69QJeWMa3//2gAMAwEAAgADAAAAEAcrv//EABgRAQEBAQEAAAAAAAAAAAAAAAERAEHw/9oACAEDAQE/EJiVdHunZgJJiDDBkXpmUu//xAAZEQEBAQADAAAAAAAAAAAAAAABABEhMZH/2gAIAQIBAT8QQJmFrj7dqEjzZWsgAv/EAB0QAQACAgIDAAAAAAAAAAAAAAERIQBBMVFhcYH/2gAIAQEAAT8QsNAJgckLMNvjeWtx5Zp5IKiVm71jNFByPZ161mlrRDgaANhaaPOIFSu1z//Z","aspectRatio":2,"src":"/static/7beb51eaf032dc60e2b0cb7b04790682/3e61c/java-7.jpg","srcSet":"/static/7beb51eaf032dc60e2b0cb7b04790682/7fcb3/java-7.jpg 192w,\n/static/7beb51eaf032dc60e2b0cb7b04790682/42594/java-7.jpg 384w,\n/static/7beb51eaf032dc60e2b0cb7b04790682/3e61c/java-7.jpg 768w,\n/static/7beb51eaf032dc60e2b0cb7b04790682/0a363/java-7.jpg 1152w,\n/static/7beb51eaf032dc60e2b0cb7b04790682/a6c62/java-7.jpg 1200w","srcWebp":"/static/7beb51eaf032dc60e2b0cb7b04790682/dd090/java-7.webp","srcSetWebp":"/static/7beb51eaf032dc60e2b0cb7b04790682/ae504/java-7.webp 192w,\n/static/7beb51eaf032dc60e2b0cb7b04790682/fef30/java-7.webp 384w,\n/static/7beb51eaf032dc60e2b0cb7b04790682/dd090/java-7.webp 768w,\n/static/7beb51eaf032dc60e2b0cb7b04790682/44170/java-7.webp 1152w,\n/static/7beb51eaf032dc60e2b0cb7b04790682/a7c53/java-7.webp 1200w","sizes":"(max-width: 768px) 100vw, 768px","presentationWidth":768,"presentationHeight":384},"resize":{"src":"/static/7beb51eaf032dc60e2b0cb7b04790682/3e61c/java-7.jpg"}}}},"fields":{"slug":"/java-memory-model/"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Everything about JVM, Java Memory Model and Garbage Collection\",\n  \"cover\": \"./java-7.jpg\",\n  \"date\": \"2020-07-12T00:00:00.000Z\",\n  \"description\": null,\n  \"tags\": [\"post\", \"java\"],\n  \"draft\": false\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h4\", {\n    \"id\": \"java-virtual-machine-technology\"\n  }, \"Java Virtual Machine Technology\"), mdx(\"p\", null, \"The JDK provides one or more implementations of the Java\\u2122 virtual machine (VM):  \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"On platforms typically used for client applications, the JDK comes with a VM implementation called the Java HotSpot\\u2122 Client VM (client VM). The client VM is tuned for reducing start-up time and memory footprint. It can be invoked by using the -client command-line option when launching an application.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"On all platforms, the JDK comes with an implementation of the Java virtual machine called the Java HotSpot Server VM (server VM). The server VM is designed for maximum program execution speed. It can be invoked by using the -server command-line option when launching an application.\\nSome features of Java HotSpot technology, common to both VM implementations, are the following.\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Adaptive compiler - Applications are launched using a standard interpreter, but the code is then analyzed as it runs to detect performance bottlenecks, or \\\"hot spots\\\". The Java HotSpot VMs compile those performance-critical portions of the code for a boost in performance, while avoiding unnecessary compilation of seldom-used code (most of the program). The Java HotSpot VMs also use the adaptive compiler to decide, on the fly, how best to optimize compiled code with techniques such as in-lining. The runtime analysis performed by the compiler allows it to eliminate guesswork in determining which optimizations will yield the largest performance benefit.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Rapid memory allocation and garbage collection - Java HotSpot technology provides for rapid memory allocation for objects, and it offers a choice of fast, efficient, state-of-the-art garbage collectors.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Thread synchronization - The Java programming language allows for use of multiple, concurrent paths of program execution (called \\\"threads\\\"). Java HotSpot technology provides a thread-handling capability that is designed to scale readily for use in large, shared-memory multiprocessor servers.\\nTools\")))), mdx(\"h4\", {\n    \"id\": \"java-memory-model\"\n  }, \"Java Memory Model\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"JVM\"), \" requires some memory for its functioning. This memory is consumed from the available memory on host OS. This can be managed programmatically by providing it in startup parameters to jvm. Inside JVM, there exist separate memory spaces \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"(Heap, Non-Heap, and Cache)\"), \" in order to store runtime data and compiled code.\"), mdx(\"span\", {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"820px\"\n    }\n  }, \"\\n      \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"42.926829268292686%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAChUlEQVQoz11Ry08acRDmL+uthyZtmjQ9kF7aQ5O2aeLJpj56UkqqUjVBIPVFLWlMeRhT01qqosK6CyqQBXm7wLLA7uIu4gN5VH5fgfTUSSb5ZibzzTczGofDAbvdDpfLBafTSXqxwWCATqfD+NgYRkaGMTo6Cr1e38+9GRzsYbK2toae93q7fX1ssVigQdearRYEQSCVSgWEdDqiWG4oylm7UpE7uVyuIclSp1gstfM836xfX5NSqQSO40i3hsbNDURRhFAs9kVpms0m2HAIJ2yYpOJRBA8jMrOXV8N+IR/058PMXuEqGkyHytkNXua+V9yhYM1ylIaJYomJOYHZG0KQjSCXzcJms0Fz052QjEWgSCVSU8rw7hxV/L+LoNzZ0t4mR7FeFbQn6lPzX+VrfhXf/HTVdHqB+YxCFvOX+EDHkc4XcFE7x/LyMjQ9ycmTCKQiTxRJALV7fEZtlcDsFlV6hxdD1CWCBzG+WnQ1LwrOljPAnJtTKj4lRLKQUTFFx5DkcqiqCqxW6z+FfcICORN5+DwBhdoSwHh4hdrO8oxHxqGXzaiCo17jHW1ngK5Z0lXMJyWyeKrC0CPM/kcYj7KQSwVyrqrw7SckynMFZv9S8W7LuZ+uLKidaLqh/Ki3pI32Kn2gzqTOYUzIxJSpYtwbRSzDQVUULC11V/7TbqH3DC6TIiy9AGZzrHr8a7Zy7DaUA+5JntmYrB7tW/h1z0dxfUsvBeLBOn3aPU2KI750DlQiA57PQ5bKcDrs0EyZbZgwfsaEyYbhty/J0MBjjAw8uh16/ZC8enYXz5/cuX3x9B602gdEq73feW8wYtZsI9NGK6bnrJgxf8GUaQUTcyt4p5vGX2rmRw7xhYw1AAAAAElFTkSuQmCC')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  })), \"\\n  \", mdx(\"img\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"java-memory\",\n    \"title\": \"java-memory\",\n    \"src\": \"/static/55998773d3933af1327d3560a71ff975/083f8/jvm-mem.png\",\n    \"srcSet\": [\"/static/55998773d3933af1327d3560a71ff975/ad4a5/jvm-mem.png 205w\", \"/static/55998773d3933af1327d3560a71ff975/74ab4/jvm-mem.png 410w\", \"/static/55998773d3933af1327d3560a71ff975/083f8/jvm-mem.png 820w\", \"/static/55998773d3933af1327d3560a71ff975/b4095/jvm-mem.png 1111w\"],\n    \"sizes\": \"(max-width: 820px) 100vw, 820px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\"\n  })), \"\\n    \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"In the image shown above for Java Memory Model:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Heap Space: Eden + Survivor + Tenured\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Non-Heap Space: Stack + MetaSpace + Reserved (Not shown here)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Cache\")))), mdx(\"h4\", {\n    \"id\": \"heap-memory\"\n  }, \"Heap Memory\"), mdx(\"p\", null, \"This is the place where objects live. Prior to Java 8, we have Permanent Generation also as part of Heap. But Java 8 onwards, this has been replaced with a non-heap memory named as MetaSpace. After Java 8, Heap Space is divided into below two parts:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"h4\", _extends({\n    parentName: \"li\"\n  }, {\n    \"id\": \"young-generation\"\n  }), \"Young Generation\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"The Young Generation is the place where all the new objects are created. When this young generation is filled, garbage collection is performed. This garbage collection is called Minor GC. Young Generation is divided into three parts \\u2013 \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Eden and two Survivor(S1, S2) Memory Spaces\"), \".\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Most of the newly created objects are located in the Eden memory space. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"When Eden space is filled with objects, Minor GC is performed and all the survivor objects are moved to one of the survivor spaces.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Minor GC also checks the survivor objects and move them to the other survivor space. So at a time, one of the survivor space is always empty.\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"h4\", _extends({\n    parentName: \"li\"\n  }, {\n    \"id\": \"old-generation\"\n  }), \"Old Generation\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Objects that are survived after many cycles of GC, are moved to the Old Generation memory space, also known as \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Tenured Space\"), \". Usually, it\\u2019s done by setting a threshold for the age of the young generation objects before they become eligible to be promoted to Old generation.\"))), mdx(\"p\", null, \"Followings are some JVM memory configurations when running resource-intensive Java programs.\"), mdx(\"blockquote\", null, mdx(\"ul\", {\n    parentName: \"blockquote\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"-Xms\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"value\"), \" - minimum or initial Heap size\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"-Xmx\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"value\"), \" - maximum Heap size\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"-Xmn\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"value\"), \" - size of Young Generation, rest of the space goes for Old Generation.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"-XX:NewSize=\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"size\"), \" - new generation heap size\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"-XX:MaxNewSizeSetting - maximum New generation heap size\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"-XX:MaxPermGenSetting - maximum size of Permanent generation\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"-XX:SurvivorRatioSetting - new heap size ratios (e.g. if Young Gen size is 10m and memory switch is \\u2013XX:SurvivorRatio=2, then 5m will be reserved for Eden space and 2.5m each for both Survivor spaces, default value = 8)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"-XX:NewRatio - providing ratio of Old/New Gen sizes (default value = 2)\"))), mdx(\"h4\", {\n    \"id\": \"non-heap-memory\"\n  }, \"Non Heap Memory\"), mdx(\"p\", null, \"The memory that doesn't belong to Heap Area, is informally referred as Non-Heap Memory. This area includes \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Stack\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"MetaSpace\"), \".\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"h4\", _extends({\n    parentName: \"li\"\n  }, {\n    \"id\": \"stack\"\n  }), \"Stack\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"This memory is used for execution of a thread and it contains method specific values and references to other objects in Heap.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"h4\", _extends({\n    parentName: \"li\"\n  }, {\n    \"id\": \"metaspace\"\n  }), \"MetaSpace\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"From Java 8 onwards, Permanent Generation has been replaced with MetaSpace, which is a non-heap memory. MetaSpace holds the reflective data of JVM itself, like Class Loader related data, Class metadata, methods and more.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"MetaSpace is not a contiguous memory and can auto increase its size up to the limit that underlying OS allows, whereas Perm Gen always has a fixed maximum size. As long as the classloader is alive, the metadata remains alive in the Metaspace and can\\u2019t be freed.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"h4\", _extends({\n    parentName: \"li\"\n  }, {\n    \"id\": \"reserved-space\"\n  }), \"Reserved Space\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Jvm has its some reserved memory space for variety of purposes.\"))), mdx(\"h4\", {\n    \"id\": \"code-cache\"\n  }, \"Code Cache\"), mdx(\"p\", null, \"  Code Cache is cache memory, that is used for the storage of compiled native codes generated by JIT compiler, JVM internal structures, loaded profiler agent code and data, etc.\"), mdx(\"h4\", {\n    \"id\": \"garbage-collection\"\n  }, \"Garbage Collection\"), mdx(\"p\", null, \"Unlike languages like C, C++, where developers have to take care of the memory management of their programs on their own, Java has feature of automatic memory management, called as \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Garbage Collection\"), \". \"), mdx(\"p\", null, \"Its a thread running in background that looks into all the objects in memory and find out that are not referenced by any part of the program to mark them for GC. All these marked Objects are deleted, and the space is reclaimed for allocation to other objects.\"), mdx(\"p\", null, \"Garbage Collection is Generational, the gc that runs in \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Young Generation\"), \" is called minor Garbage Collection and the one that runs in \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Old Generation\"), \", is called the full Garbage Collection.\"), mdx(\"p\", null, \"Full Garbage collection is more expensive in terms of resources, as deleting live objects from Old Generation requires more efforts and is slower, compared to deleting unreferenced objects from Young Generation. Therefore full GC's are \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"\\u201CStop the World\\u201D\"), \" events because all application threads are stopped until the operation completes.\"), mdx(\"h4\", {\n    \"id\": \"garbage-collection-types\"\n  }, \"Garbage Collection Types\"), mdx(\"p\", null, \"There are five types of garbage collection that we can use in our applications. We just need to use the JVM switch to enable the garbage collection strategy for the application. Let\\u2019s look at each of them one by one.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Serial GC (-XX:+UseSerialGC):\"), \" Serial GC uses the simple mark-sweep-compact approach for young and old generations garbage collection i.e Minor and Major GC.Serial GC is useful in client machines such as our simple stand-alone applications and machines with smaller CPU. It is good for small applications with low memory footprint.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Parallel GC (-XX:+UseParallelGC):\"), \" Parallel GC is same as Serial GC except that is spawns N threads for young generation garbage collection where N is the number of CPU cores in the system. We can control the number of threads using -XX:ParallelGCThreads=n JVM option. Parallel Garbage Collector is also called throughput collector because it uses multiple CPUs to speed up the GC performance. Parallel GC uses a single thread for Old Generation garbage collection.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Parallel Old GC (-XX:+UseParallelOldGC):\"), \" This is same as Parallel GC except that it uses multiple threads for both Young Generation and Old Generation garbage collection.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Concurrent Mark Sweep (CMS) Collector (-XX:+UseConcMarkSweepGC):\"), \" CMS Collector is also referred as concurrent low pause collector. It does the garbage collection for the Old generation. CMS collector tries to minimize the pauses due to garbage collection by doing most of the garbage collection work concurrently with the application threads.CMS collector on the young generation uses the same algorithm as that of the parallel collector. This garbage collector is suitable for responsive applications where we can\\u2019t afford longer pause times. We can limit the number of threads in CMS collector using -XX:ParallelCMSThreads=n JVM option.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"G1 Garbage Collector (-XX:+UseG1GC):\"), \" The Garbage First or G1 garbage collector is available from Java 7 and its long term goal is to replace the CMS collector. The G1 collector is a parallel, concurrent, and incrementally compacting low-pause garbage collector. Garbage First Collector doesn\\u2019t work like other collectors and there is no concept of Young and Old generation space. It divides the heap space into multiple equal-sized heap regions. When a garbage collection is invoked, it first collects the region with lesser live data, hence \\u201CGarbage First\\u201D. You can find more details about it at Garbage-First Collector Oracle Documentation.\"))), mdx(\"h4\", {\n    \"id\": \"brief-overview-of-hotspot-jvm-architecture\"\n  }, \"Brief overview of Hotspot JVM Architecture:\"), mdx(\"span\", {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"820px\"\n    }\n  }, \"\\n      \", mdx(\"span\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"75.1219512195122%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAAsSAAALEgHS3X78AAACZ0lEQVQoz6WSTW/aQBCG+dU9V+qhbRT1D7RSpapJSYhokwApaqXQNCFKwS4QCMHGscEfeI29tlnjz11vN9AkSg+5dDQ7msO+80rPTIE+jizL4jjGGKdpmiTJ34a9LCOE/PO5cN/lec6qYRjNZrPT6YwEYdDvS+Ko1+F5rsW3W8Cc3X97EOerZCbMKorjKIqCIMA4k/V5sTHaPZV2TsTiibB3Km01xLPumEnIasSDcxyFrmM5cxAGiyBYkCS4uFJfVpQ3de11Vd6oTjZr8osvUv188EjsR9jwsRVQgAhL1pisIjJ1EhGEF329djws1/vtayDOkO4mhk+8MFuLSc/Mtjmv+Ms8GJGqgHc5+2CY7I9ouefvD9DhdbbXsj/+nJR7QU2iJW5e6i27M8yEBZoTO8SyjUQNqIiCkBp+aC6JGlDFgoIGrJSOgfujxQ91b4pok+/2ZN0OCRMWGL0wShNMU0wTQlNyC8/xl4pmGcAxLaiZtuMi212gKIsz6i1CH8VhnOZrMeN8y5xgy3IBcCFEDDy0Lceee9CZWxZCAQPEth0gxFClGWZrvwOGloOJ07uxypXO56PL2rEwUGF/6g1Uv3tjawCu14GW0cxy8tWq8zvaeaWtvjrSN7+q7xpGqTXbbYHtNvxwppY4c+NwtFXnGZswSt5XWm+/SQrECw8qyoQdHAOGP51pz7YGz/e16pheKQYnTLsmafDXv4dCsTnZ+d5JIwRd75y7PG1f2W5gGDrH8xDCW+ex4V2INid7Q9VTdHusWpLhy7ozMeFQBosgXF0lxVmWJjHBmPXs2FfO/xGF9dQn8on4A8kQOqeAtC92AAAAAElFTkSuQmCC')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  })), \"\\n  \", mdx(\"img\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"java-hotspot\",\n    \"title\": \"java-hotspot\",\n    \"src\": \"/static/baaf4aeba147a1a1e01413a58f2d2496/083f8/java-hotspot.png\",\n    \"srcSet\": [\"/static/baaf4aeba147a1a1e01413a58f2d2496/ad4a5/java-hotspot.png 205w\", \"/static/baaf4aeba147a1a1e01413a58f2d2496/74ab4/java-hotspot.png 410w\", \"/static/baaf4aeba147a1a1e01413a58f2d2496/083f8/java-hotspot.png 820w\", \"/static/baaf4aeba147a1a1e01413a58f2d2496/7d769/java-hotspot.png 960w\"],\n    \"sizes\": \"(max-width: 820px) 100vw, 820px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\"\n  })), \"\\n    \"), mdx(\"blockquote\", null, mdx(\"h5\", _extends({\n    parentName: \"blockquote\"\n  }, {\n    \"id\": \"sources\"\n  }), \"Sources:\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Orcale JDK Documentations\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Few More Important Resources that can be checked out:\"), mdx(\"ul\", {\n    parentName: \"blockquote\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html\"\n  }), \"Table for Oracle JavaSE VM Options (SE 7 and Earlier)\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html\"\n  }), \"All Java Hotspot VM command line flags for Java 8\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://docs.oracle.com/javase/7/docs/technotes/tools/solaris/java.html\"\n  }), \"All Java Hotspot VM command line flags for Java 7\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://www.oracle.com/webfolder/technetwork/tutorials/mooc/JVM_Troubleshooting/week1/lesson1.pdf\"\n  }), \"Oracle JVM Troubleshooting Memory\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://docs.oracle.com/cd/E19900-01/819-4742/index.html\"\n  }), \"Sun Java System Application Server Enterprise Edition 8.2 Performance Tuning Guide\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://docs.oracle.com/cd/E19900-01/819-4742/abeij/index.html\"\n  }), \"Guidelines for Java SE 8.2 Heap Sizing\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://docs.oracle.com/cd/E19900-01/819-4742/abeik/index.html\"\n  }), \"Java SE 8.2 Heap Tuning Parameters\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://docs.oracle.com/en/java/javase/index.html\"\n  }), \"All Java Platform, Standard Edition Documentation\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://docs.oracle.com/en/java/javase/14/\"\n  }), \"JDK 14 Documentation\")))));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"d075a19e-4c79-524a-ab3d-e0288554b667"}}}