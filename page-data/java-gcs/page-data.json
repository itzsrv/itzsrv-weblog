{"componentChunkName":"component---node-modules-gatsby-theme-chronoblog-src-templates-post-js","path":"/java-gcs/","result":{"data":{"mdx":{"id":"f1aa889e-6150-5e02-a1f3-19738fe2c220","excerpt":"Unlike languages like C or C++, where developers have to take care of memory management of their programs on their own, Java has feature ofâ€¦","frontmatter":{"title":"Getting hang of Java Garbage Collection","date":"2020-07-19T00:00:00.000Z","description":"Everything about Garbage Collection, gc switches and its logs monitoring tools","tags":["post","java"],"cover":null},"fields":{"slug":"/java-gcs/"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Getting hang of Java Garbage Collection\",\n  \"cover\": null,\n  \"date\": \"2020-07-19T00:00:00.000Z\",\n  \"description\": \"Everything about Garbage Collection, gc switches and its logs monitoring tools\",\n  \"tags\": [\"post\", \"java\"],\n  \"draft\": false\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Unlike languages like C or C++, where developers have to take care of memory management of their programs on their own, Java has feature of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"automatic memory management\"), \", called as \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Garbage Collection\"), \". \"), mdx(\"p\", null, \"It's a thread running in background that looks into memory and finds out those objects that are not referenced anymore by any part of the program. These unreferenced Objects are deleted, and the space is reclaimed for allocation to other objects.\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"GC is based on a couple of hypothesis:\")), mdx(\"ol\", {\n    parentName: \"blockquote\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Most objects soon become unreachable.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"References from 'old' objects to 'young' objects only exist in small numbers.\"))), mdx(\"p\", null, \"GC is carried out by daemon thread known as Garbage Collector. There is no way to force guaranteed GC to happen explicitly. Although there are API's available like System.gc() to trigger the GC, but the final decison resides with JVM.\"), mdx(\"p\", null, \"If new allocations can not happen due to no free memory available on heap, it will throw \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"java.lang.OutOfMemoryError heap space\"), \".\"), mdx(\"p\", null, \"Garbage Collection is Generational, the gc that runs in Young Generation is called \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"minor Garbage Collection\"), \" and the one that runs on entire heap, is called \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"full Garbage Collection\"), \". \"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"A typical full GC involves following three steps:\"), mdx(\"ol\", {\n    parentName: \"blockquote\"\n  }, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Mark\"), \": Starts from root node of your application(main), walks the object graph, marks objects that are reachable as live\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Sweep or Delete:\"), \" Delete unreachable objects\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Compacting\"), \": Compact the memory by moving around objects and making allocation contiguous than fragmented.\"))), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Since the newly created objects are always placed in Eden Space, once this space becomes full, any new allocation fails. Hence minor GC kicks in, moving all marked live objects to Survivor Spaces and all remaining dead objects are deleted, emtying the Eden Space.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Next minor GC also checks in for live objects in first survivor space and moves them to other survivor space, and empties the first survivor space by freeing up unreferenced objects, and vice-versa. So at a time, one of the survivor space is always empty. Thus, having two survivor spaces save one extra step of Compacting in minor GC by moving fragmented objects alternatively in contiguous locations in survivor spaces.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Live objects are moved back and forth in alternate Survivor Spaces until the Objects survive a threshold number of GCs, after which all surviving objects are promoted to next generation, called as Old Generation.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"-XX:MaxTenuringThreshold : switch to set GC threshold for promoting to Old Generation \"))), mdx(\"p\", null, \"Once the Old Generation is almost full, full GC kicks in, which runs on entire Heap from Young Generation to Old Generation and performs \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"mark\"), \", \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"sweep\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"compacting\"), \". And this GC is more expensive in terms of resources, as performing full GC on entire Heap requires more efforts and is slower, compared to performing minor GC on Young Generation which is quick, because it runs only on a section of Heap Space (eden and survivor space). \"), mdx(\"p\", null, \"Although, operation in minor GC is quick and not that intrusive, it doesn't really seem like halting the application but irrespective of that, all GC's are \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"\\u201CStop the World\\u201D\"), \" events, because all application threads are stopped until the GC operation completes. \"), mdx(\"h4\", {\n    \"id\": \"application-performance-with-respect-to-gc\"\n  }, \"Application Performance with respect to GC\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Responsiveness or latency\")), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"It is time taken by an Application to respond with a requested piece of data. E.g. how quickly a desktop UI responds to an event, or a website returns a page.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"For Applications that focus on responsiveness, large pause times are not acceptable. The focus is on responding in short period of time.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Throughput\")), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"It is maximum amount of work done by Application in a specific period of time. E.g. the number of transactions completed in a given time.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"High pause times are acceptable for applications that focus on throughput. Since high throughput applications focus on benchmarks over longer periods of time, quick response time is not a consideration.\"))), mdx(\"h4\", {\n    \"id\": \"garbage-collection-types\"\n  }, \"Garbage Collection Types\"), mdx(\"p\", null, \"There are basically five types of garbage collectors that we can use in our applications. We just need to use the JVM switch to enable garbage collection strategy for the application. Let\\u2019s look at each of them one by one.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Serial GC (-XX:+UseSerialGC):\"), \" Serial GC is a very basic GC that comes with Java, uses the simple mark-sweep-compact approach using single thread. It is good for small applications with low memory footprint.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Parallel GC (-XX:+UseParallelGC):\"), \" Parallel GC is same as Serial GC except that it spawns N threads for young generation garbage collection where N is the number of CPU cores in the system. We can control number of threads using -XX:ParallelGCThreads=n JVM option. Parallel Garbage Collector is also called throughput collector because it uses multiple CPUs to speed up GC performance. Parallel GC uses a single thread for Old Generation garbage collection.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Parallel Old GC (-XX:+UseParallelOldGC):\"), \" This is same as Parallel GC except that it uses multiple threads for both Young Generation and Old Generation garbage collection.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Concurrent Mark Sweep (CMS) Collector (-XX:+UseConcMarkSweepGC):\"), \" CMS Collector is also referred as concurrent low pause collector. It does GC for the Old generation and tries to minimize pauses due to GC by doing most of the garbage collection work concurrently with application threads without waiting for Old Generation to get full. It does not pauses the application for most of the GC operations. It only pasuses for Mark/Remark step. CMS collector on the young generation uses same algorithm as that of the parallel collector. This garbage collector is suitable for responsive applications where we can\\u2019t afford longer pause times. We can limit the number of threads in CMS collector using -XX:ParallelCMSThreads=n JVM option. It is the most favored GC for most of the Web and Financial Applications.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"G1 Garbage Collector (-XX:+UseG1GC):\"), \" The Garbage First or G1 Garbage Collector is available from Java 7 and its long term goal is to replace the CMS collector. The G1 collector is a parallel, concurrent, and incrementally compacting low-pause garbage collector. Garbage First Collector doesn\\u2019t work like other collectors and there is no concept of Young and Old generation space. It divides heap space into multiple equal-sized heap regions. When a garbage collection is invoked, it first collects the region with lesser live data, hence \\u201CGarbage First\\u201D. You can find more details about it at \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://docs.oracle.com/javase/9/gctuning/garbage-first-garbage-collector.htm#JSGCT-GUID-082C967F-2DAC-4B59-8A81-0CEC6EEB9016\"\n  }), \"Garbage-First Collector Oracle Documentation\"), \".\"))), mdx(\"h4\", {\n    \"id\": \"enabling-gc-logging\"\n  }, \"Enabling GC Logging\"), mdx(\"p\", null, \"If GC is behaving suspiciously, then below logging switches can be enabled for analyzing performance with respect to GC:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"-verbose:gc\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"-XX:+PrintGCDetails\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"-Xloggc:gc.log\")), mdx(\"h4\", {\n    \"id\": \"gc-tools\"\n  }, \"GC Tools\"), mdx(\"p\", null, \"There are some tools that can be used for GC aid:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Garbage Collection Log Analyzer from IBM\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"VisualVM : free tool that comes with jdk instalation, command: jvisualvm (a helpful plugin visualgc)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Java Heap Analysis Tool (jhat)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"TerraCotta Big Memory\")), mdx(\"blockquote\", null, mdx(\"h5\", _extends({\n    parentName: \"blockquote\"\n  }, {\n    \"id\": \"references\"\n  }), \"References:\"), mdx(\"ul\", {\n    parentName: \"blockquote\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Orcale JDK Documentations\")), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Few More Important Resources that can be checked out:\"), mdx(\"ul\", {\n    parentName: \"blockquote\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://www.oracle.com/webfolder/technetwork/tutorials/mooc/JVM_Troubleshooting/week1/lesson1.pdf\"\n  }), \"Oracle JVM Troubleshooting Memory\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://docs.oracle.com/cd/E19900-01/819-4742/index.html\"\n  }), \"Sun Java System Application Server Enterprise Edition 8.2 Performance Tuning Guide\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://docs.oracle.com/cd/E19900-01/819-4742/abeij/index.html\"\n  }), \"Guidelines for Java SE 8.2 Heap Sizing\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://docs.oracle.com/cd/E19900-01/819-4742/abeik/index.html\"\n  }), \"Java SE 8.2 Heap Tuning Parameters\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://docs.oracle.com/en/java/javase/index.html\"\n  }), \"All Java Platform, Standard Edition Documentation\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://docs.oracle.com/javase/9/gctuning/introduction-garbage-collection-tuning.htm#JSGCT-GUID-326EB4CF-8C8C-4267-8355-21AB04F0D304\"\n  }), \"Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide\")))));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"id":"f1aa889e-6150-5e02-a1f3-19738fe2c220"}}}